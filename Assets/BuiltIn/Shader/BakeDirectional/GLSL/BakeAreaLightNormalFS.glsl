// File Generated by Assets/BuildShader.py - source: [BakeAreaLightFS.d.glsl : LM,NORMAL_MAP]
precision highp float;
precision highp samplerCube;
uniform sampler2D uTexNormal;
in vec2 varTex0;
in vec3 varWorldPosition;
in vec3 varWorldNormal;
in vec3 vWorldTangent;
in vec3 vWorldBinormal;
in float vTangentW;
uniform vec4 uLightPosition;
uniform vec3 uLightDirX;
uniform vec3 uLightDirY;
uniform vec2 uLightSize;
uniform vec4 uLightColor;
out vec4 FragColor;
vec3 integrateEdge(vec3 v1, vec3 v2)
{
    float x = dot(v1, v2);
    float y = abs(x);
    float a = 0.8543985 + (0.4965155 + 0.0145206*y)*y;
    float b = 3.4175940 + (4.1616724 + y)*y;
    float v = a / b;
    float theta_sintheta = (x > 0.0) ? v : 0.5*inversesqrt(max(1.0 - x*x, 1e-7)) - v;
    return cross(v1, v2)*theta_sintheta;
}
vec3 arealight(
	const vec3 position,
	const vec3 normal,
	const vec3 camPosition,
	const vec4 lightColor,
	const vec3 lightPosition,
	const vec3 lightDirX,
	const vec3 lightDirY,
	const vec2 lightSize)
{
	vec3 v0 = lightPosition - lightDirX * lightSize.x - lightDirY * lightSize.y;
	vec3 v1 = lightPosition + lightDirX * lightSize.x - lightDirY * lightSize.y;
    vec3 v2 = lightPosition + lightDirX * lightSize.x + lightDirY * lightSize.y;
    vec3 v3 = lightPosition - lightDirX * lightSize.x + lightDirY * lightSize.y;
    vec3 L[4];
    L[0] = (v0 - position);
    L[1] = (v1 - position);
    L[2] = (v2 - position);
    L[3] = (v3 - position);
	L[0] = normalize(L[0]);
    L[1] = normalize(L[1]);
    L[2] = normalize(L[2]);
    L[3] = normalize(L[3]);
	vec3 sum = vec3(0.0, 0.0, 0.0);
	sum += integrateEdge(L[0], L[1]);
	sum += integrateEdge(L[1], L[2]);
	sum += integrateEdge(L[2], L[3]);
	sum += integrateEdge(L[3], L[0]);
	float len = length(sum);
	vec3 dir = v0 - position;
    vec3 lightNormal = cross(v1 - v0, v3 - v0);
	float t = step(dot(dir, lightNormal), 0);
	len = len * t;
	return max(0.0, len) * lightColor.rgb * lightColor.a;
}
void main(void)
{
	vec3 normalMap = texture(uTexNormal, varTex0).xyz;
	mat3 rotation = mat3(vWorldTangent, vWorldBinormal, varWorldNormal);
	vec3 localCoords = normalMap * 2.0 - vec3(1.0, 1.0, 1.0);
	localCoords.y *= vTangentW;
	vec3 worldNormal = normalize(rotation * localCoords);
	vec3 directionalLightColor = arealight(
		varWorldPosition,
		worldNormal,
		vec3(0.0, 100.0, 0.0),
		uLightColor,
		uLightPosition.xyz,
		uLightDirX,
		uLightDirY,
		uLightSize);
	FragColor = vec4(directionalLightColor / 3.0, 1.0);
}
