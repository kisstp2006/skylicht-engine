// File Generated by Assets/BuildShader.py - source: [BakeDirectionalLightFS.d.glsl : LM,NORMAL_MAP]
precision mediump float;
uniform sampler2D uShadowMap;
uniform sampler2D uTexNormal;
in vec2 varTex0;
in vec3 varWorldPosition;
in vec3 varWorldNormal;
in vec3 vWorldTangent;
in vec3 vWorldBinormal;
in float vTangentW;
uniform vec4 uLightColor;
uniform vec4 uLightDirection;
uniform vec4 uShadowBias;
uniform mat4 uShadowMatrix;
out vec4 FragColor;
float shadowSimple(const vec4 shadowCoord)
{
	int id = 0;
	float visible = 1.0;
	float depth = 0.0;
	float result = 0.0;
	vec3 shadowUV = shadowCoord.xyz / shadowCoord.w;
	depth = shadowUV.z;
	depth -= uShadowBias.x;
	vec2 uv = shadowUV.xy;
	float size = 1.0/2048.0;
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(-1, -1) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(0, -1) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(1, -1) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(-1, 0) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(0, 0) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(1, 0) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(-1, 1) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(0, 1) * size), 0.0).r));
	result += (step(depth, textureLod(uShadowMap, vec2(uv + vec2(1, 1) * size), 0.0).r));
	return result / 9.0;
}
void main(void)
{
	vec3 normalMap = texture(uTexNormal, varTex0).xyz;
	mat3 rotation = mat3(vWorldTangent, vWorldBinormal, varWorldNormal);
	vec3 localCoords = normalMap * 2.0 - vec3(1.0, 1.0, 1.0);
	localCoords.y *= vTangentW;
	vec3 worldNormal = normalize(rotation * localCoords);
	vec4 shadowCoord = uShadowMatrix * vec4(varWorldPosition, 1.0);
	float visibility = shadowSimple(shadowCoord);
	float NdotL = max(dot(worldNormal, uLightDirection.xyz), 0.0);
	vec3 directionalLightColor = NdotL * uLightColor.rgb / 3.0;
	FragColor = vec4(directionalLightColor * visibility, visibility);
}
